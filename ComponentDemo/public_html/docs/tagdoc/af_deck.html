<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.4 at 2019-08-19 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>ADF RichClient API - 
  <af:deck></title>
    <style type="text/css" media="all">
      @import url("../css/maven-base.css");
      @import url("../css/maven-theme.css");
      @import url("../css/site.css");
    </style>
    <link rel="stylesheet" href="../css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20190819" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                        <a href="http://www.oracle.com" id="bannerLeft">
                                                <img src="../../images/oracle_logo_red_large.png" alt="Oracle ADF Faces Rich Client" />
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2019-08-19</span>
                  &nbsp;| <span id="projectVersion">Version: 12-aspen-SNAPSHOT</span>
                      </div>
            <div class="xright">        
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        
 
 <div class="section">
<h2>Summary<a name="Summary"></a></h2>
 
<p></p>

<div class="summary">

<table border="0" class="bodyTable">

<tr class="a">

<td><b>Tag Name:</b></td>
<td>&lt;af:deck&gt;</td>
</tr>

<tr class="b">

<td><b>Java Class:</b></td>
<td><a href="../apidocs/oracle/adf/view/rich/component/rich/layout/RichDeck.html">oracle.adf.view.rich.component.rich.layout.RichDeck</a></td>
</tr>

<tr class="a">

<td><b>Component Type:</b></td>
<td>oracle.adf.RichDeck</td>
</tr>
</table>
</div>
The deck component is a container that shows one child component at a time. When changing which child is displayed, the transition can be animated.
        
<p></p>
        This component does not provide any built-in controls for choosing which child is displayed. Instead, you use some other component to control it. For example, you might use an external navigationPane tab bar or perhaps some external commandImageLinks to represent page progress dots. You are not limited to external controls, your deck might be displaying a series of images and you may want to put a link around each image to trigger advancing to the next image. In all of these cases, you will need to use an event handler function to change the displayed child.
        
<p></p>
        This example shows how to dynamically find the nearest deck ancestor, assign a new displayedChild value, and then trigger the transition animation:
        
<div class="source">
<pre>
// Action listener for navigating to the 1st card of a deck.
public void animateToFirstCard(ActionEvent e)
{
  UIComponent eventComponent = e.getComponent();
  _animateDeckDisplayedChild(eventComponent, 0);
}

// Action listener for navigating to the 2nd card of a deck.
public void animateToSecondCard(ActionEvent e)
{
  UIComponent eventComponent = e.getComponent();
  _animateDeckDisplayedChild(eventComponent, 1);
}

// Animate the display of a deck child.
private void _animateDeckDisplayedChild(
  UIComponent eventComponent,
  int newDisplayedChildIndex)
{
  // Find the nearest deck ancestor:
  RichDeck deck = null;
  String eventComponentId = eventComponent.getId();
  while (deck == null)
  {
    if (eventComponent == null)
    {
      System.err.println(&quot;Unable to locate a deck ancestor from id &quot; + eventComponentId);
      return;
    }
    else if (eventComponent instanceof RichDeck)
    {
      deck = (RichDeck)eventComponent;
      break;
    }
    eventComponent = eventComponent.getParent();
  }

  String newDisplayedChild = deck.getChildren().get(newDisplayedChildIndex).getId();

  // Update the displayedChild:
  deck.setDisplayedChild(newDisplayedChild);

  // Add this component as a partial target:
  RequestContext rc = RequestContext.getCurrentInstance();
  rc.addPartialTarget(deck);
}
        </pre></div>
        In order to choose what the transition will look like when changing the deck's displayedChild, place one or two af:transition tags inside of the af:deck tag. This tag will let you choose an animation style and what kind of transition will trigger that type of animation. In order for a transition to take effect, the deck must be redrawn but not some ancestor of the deck because if an ancestor is redrawn the old state for the deck will be lost (nothing to transition from).
        
<p></p>
        Many of the transition animations will give a different effect based on the width and height of the deck component. In most cases, you will either want to explicitly assign a width and height inlineStyle to constrain the dimensions of the deck or place the deck in a container that provides dimensions. For example, if the deck were displaying one playing card at a time, you would want your deck's dimensions to match the dimensions of the playing card. If you allowed the deck to display using the full width of the page, a horizontal flip transition will look funny because the axis of the flip will be the middle of the deck, not the middle of the playing card.
        
<p></p>
        Some of the transition animations can cause content to bleed outside of the deck's dimensions during the transition animation. If this effect is undesirable for your use case, you can add an &quot;overflow:hidden&quot; inlineStyle. When using this style, make sure your deck is constrained to a width and height (or is being stretched by an ancestor component) or else the user won't be able to see it because the deck will display with a zero pixel height.
        
<p></p>
        <b>Transition Trigger Types</b>
        
<ul>
        
<li>backNavigate - Transitioning from a later child to an earlier child (in terms of sibling order)</li>
        
<li>forwardNavigate - Transitioning from an earlier child to a later child (in terms of sibling order)</li>
        
<li>replace - Transitioning a component that is being refreshed through partial page refresh(PPR)</li>
        </ul>
        <b>Transition Animations</b>
        
<ul>
        
<li>none - No animation between items; the default and also the type used if another specified animation type is not supported on a platform</li>
        
<li>fade - A gradual opacity change between the items (see note 1)</li>
        
<li>flipUp - imagine the 2 items sandwiched, the bottom of the sandwich moves toward the user and continues upward until the sandwich is flipped a full 180 degrees (see note 2)</li>
        
<li>flipDown - imagine the 2 items sandwiched, the top of the sandwich moves toward the user and continues downward until the sandwich is flipped a full 180 degrees (see note 2)</li>
        
<li>flipStart - imagine the 2 items sandwiched, the end of the sandwich moves toward the user and continues in the start direction until the sandwich is flipped a full 180 degrees (see note 2)</li>
        
<li>flipEnd - imagine the 2 items sandwiched, the start of the sandwich moves toward the user and continues in the end direction until the sandwich is flipped a full 180 degrees (see note 2)</li>
        
<li>flipLeft - imagine the 2 items sandwiched, the right of the sandwich moves toward the user and continues in the left direction until the sandwich is flipped a full 180 degrees (see note 2)</li>
        
<li>flipRight - imagine the 2 items sandwiched, the left of the sandwich moves toward the user and continues in the right direction until the sandwich is flipped a full 180 degrees (see note 2)</li>
        
<li>slideUp - imagine the 2 items stacked vertically, they both move up (see note 1)</li>
        
<li>slideDown - imagine the 2 items stacked vertically, they both move down (see note 1)</li>
        
<li>slideStart - imagine the 2 items stacked horizontally, they both move in the start direction (see note 1)</li>
        
<li>slideEnd - imagine the 2 items stacked horizontally, they both move in the end direction (see note 1)</li>
        
<li>slideLeft - imagine the 2 items stacked horizontally, they both move in the left direction (see note 1)</li>
        
<li>slideRight - imagine the 2 items stacked horizontally, they both move in the right direction (see note 1)</li>
        </ul>
        Note, these transition animations will not work in all browsers. They require whichever is newer, the minimum browser requirements specified in the release notes or the following:
        
<ol style="list-style-type: decimal">
        
<li>= Chrome 14, Firefox 16, IE 10, or Safari 5.1</li>
        
<li>= Chrome 14, Firefox 19, IE 10, or Safari 5.1</li>
        </ol>
         When using an animation, you will not see components that use programmatic geometry management appear in their final state until after the animation is complete. This effect may be more pronounced depending on the complexity of your component struture so you may need to evaluate whether an animation is appropriate.
        
<p></p>
        <b>Note about stretching layouts and flowing/scrolling layouts:</b>
        
<p></p>
        With today's web browsers, it is not reliable to have vertically-stretched
        content inside of areas that also have scroll bars.
        If you want the outer areas of your page structure to stretch, you need to
        be careful of how you assemble your component tree.
        
<ul>
        
<li>
        First, build up a structure of stretchable components (using panelSplitters
        or panelGridLayouts).
        </li>
        
<li>
        Second, inside of this structure, create islands of non-stretched content.
        </li>
        </ul>
        Rules of thumb:
        
<ol style="list-style-type: decimal">
        
<li>
        Never nest one scrolling container inside of another scrolling
        container since users do not like nested scroll bars.
        </li>
        
<li>
        Never specify percentage heights in any component's inlineStyle attribute.
        </li>
        
<li>
        Never use the &quot;position&quot; style in any component's inlineStyle attribute.
        </li>
        </ol>
        If you believe that you need to break one of these rules, this is an
        indication that your page structure is not following the page structure
        guidelines and you will likely have troubles getting your application to
        render consistently across various web browsers and computing platforms.
        
<ul>
        
<li>
        For specific details about component stretching, please see the
        &quot;geometry management&quot; section in the tag documentation of each component.
        </li>
        
<li>
        See the demo application for real world layout examples that you can use as a
        starting point in your application.  A good starting point is the &quot;Layout
        Basics&quot; page listed under the &quot;Framework Features&quot; tab of the demo
        application.
        </li>
        </ul>
        
<p></p>
You may also alternatively place a facetRef or switcher inside of the deck and
their resolved children will be treated as if they were direct children of the deck.
If the children are stamped out via af:iterator, you can use locator syntax like
displayedChild=&quot;iterId[0]:stampChildId&quot; (where zero represents the desired stamp index).


<p></p>
  On devices that support touch, Deck supports navigating between the child components by swipe
  gesture if:
  
<ul>
    
<li>
      the transition types for forwardNavigate and backNavigate are horizontal (start,
      end, left or right) and in opposite directions (e.g. if forwardNavigate is left, backNavigate
      should be right).
    </li>
    
<li>
      A displayChangeListener is registered on the component. The application is expected to sync
      the status of external controls used for deck navigation by implementing a displayChangeListener
    </li>
  </ul>
  
<p></p>
    Deck queues DisplayChangeEvent on swipe based navigation.
    Slide animation will be initiated while swiping to transition between children.
    Transition animations that is configured via af:transition tag will NOT be initiated.
  


<div class="section">
<h2>Geometry Management<a name="Geometry_Management"></a></h2>

<ul>

<li>This component can be stretched by a parent layout component that stretches its children, e.g. panelSplitter.</li>

<li>This component will stretch the displayed child component if the deck is also being stretched. If you don't want a child to be stretched in such scenarios, you will need to surround it with a panelGroupLayout layout=&quot;scroll&quot;.</li>
</ul>
 
<p></p>
 </div>
 
<div class="section">
<h2>Screenshot(s)<a name="Screenshots"></a></h2>
 
<p>
   <html>
    
<div class="screenshot">
<img src="../images/deck.jpg" alt="deck screenshot" /></img><br />The deck component is a container that shows one child component at a time. When changing which child is displayed, the transition can be animated.
    </div>
   </html>
 </p>
 </div>
 
<div class="section">
<h2>Code Example(s)<a name="Code_Examples"></a></h2>
 
<p>
   <html>
    
<div class="source">
      </p>
<div>
<pre>
&lt;af:deck id=&quot;d1&quot;&gt;
  &lt;af:transition triggerType=&quot;backNavigate&quot; transition=&quot;flipEnd&quot;/&gt;
  &lt;af:transition triggerType=&quot;forwardNavigate&quot; transition=&quot;flipStart&quot;/&gt;
  &lt;af:panelGroupLayout id=&quot;pgl1&quot; layout=&quot;scroll&quot;&gt;
    &lt;af:outputText id=&quot;ot1&quot; value=&quot;Card 1&quot;/&gt;
  &lt;/af:panelGroupLayout&gt;
  &lt;af:panelGroupLayout id=&quot;pgl2&quot; layout=&quot;scroll&quot;&gt;
    &lt;af:outputText id=&quot;ot2&quot; value=&quot;Card 2&quot;/&gt;
  &lt;/af:panelGroupLayout&gt;
&lt;/af:deck&gt;</pre></div>
    </div>
   </html>
 
 </div>
 
<div class="section">
<h2>Supported Client Events for Client Behaviors<a name="Supported_Client_Events_for_Client_Behaviors"></a></h2>
 
<p>
</p>
<table border="0" class="bodyTable">
<tbody>

<tr class="a">

<td>

<ul>

<li>click</li>

<li>contextMenu</li>

<li>dblClick</li>

<li>displayChange</li>
</ul>
</td>

<td>

<ul>

<li>mouseDown</li>

<li>mouseMove</li>

<li>mouseOut</li>

<li>mouseOver</li>
</ul>
</td>

<td>

<ul>

<li>mouseUp</li>

<li>propertyChange <small>(default)</small></li>
</ul>
</td>
</tr>
</tbody>
</table>
 
 </div>
 
<div class="section">
<h2>Events<a name="Events"></a></h2>
 
<p>
</p>
<table border="0" class="bodyTable">

<tr class="a">

<th>Type</th>

<th>Phases</th>

<th>Description</th>
</tr>

<tr class="b">

<td>oracle.adf.view.rich.event.DisplayChangeEvent</td>
<td nowrap="nowrap">Apply Request Values,<br />Invoke Application</td>
<td>DisplayChangeEvent is a notification that the displayed child property of the source
        component is changed by an user action on the component.

        This event is currently used by af:deck component and can be used for similar usecases by
        other components in future.</td></tr>

<tr class="a">

<td>org.apache.myfaces.trinidad.event.AttributeChangeEvent</td>
<td nowrap="nowrap">Invoke Application,<br />Apply Request Values</td>
<td>Event delivered to describe an attribute change.  Attribute change events are not delivered for any programmatic change to a property.  They are only delivered when a renderer changes a property without the application's specific request.  An example of an attribute change event might include the width of a column that supported client-side resizing.</td></tr>
</table>
 
 </div>
 
<div class="section">
<h2>Attributes<a name="Attributes"></a></h2>

<table border="0" class="bodyTable">

<tr class="a">

<th>Name</th>

<th>Type</th>

<th>Supports EL?</th>

<th>Description</th>
</tr>

<tr class="b">

<td>attributeChangeListener</td>
<td>javax.el.MethodExpression</td>
<td>Only EL</td>
<td>
a method reference to an attribute change listener.  Attribute change events are not delivered for any programmatic change to a property.  They are only delivered when a renderer changes a property without the application's specific request.  An example of an attribute change events might include the width of a column that supported client-side resizing.</td>
</tr>

<tr class="a">

<td>binding</td>
<td>oracle.adf.view.rich.component.<br />rich.layout.RichDeck</td>
<td>Only EL</td>
<td>
an EL reference that will store the component instance on a
bean.  This can be used to give programmatic access to a component
from a backing bean, or to move creation of the component to a backing bean.</td>
</tr>

<tr class="b">

<td>clientComponent</td>
<td>boolean</td>
<td>Yes</td>
<td>

<b>Default Value:</b> false<br />
<br />whether a client-side component will be generated.  A component may be generated whether or not this flag is set, but if client Javascript requires the component object, this must be set to true to guarantee the component's presence.  Client component objects that are generated today by default may not be present in the future;  setting this flag is the only way to guarantee a component's presence, and clients cannot rely on implicit behavior.  However, there is a performance cost to setting this flag, so clients should avoid turning on client components unless absolutely necessary. For the components outputText and outputFormatted, setting the clientComponent to true will render id attribute for the html DOM. This ID attribute can alternatively be generated by setting oracle.adf.view.rich.SUPPRESS_IDS to &quot;auto&quot; in web.xml.</td>
</tr>

<tr class="a">

<td>customizationId</td>
<td>String</td>
<td>Yes</td>
<td>
<b>This attribute is deprecated. This attribute will be removed in the next release. Use the 'id' attribute instead.</b><br /><br />This attribute is deprecated. The 'id' attribute should be used when applying persistent customizations. This attribute will be removed in the next release.</td>
</tr>

<tr class="b">

<td>dimensionsFrom</td>
<td>String</td>
<td>Yes</td>
<td>

<b>Valid Values:</b> auto, children, parent<br />

<b>Default Value:</b> auto<br />
<br />
<p></p>determines how the component will handle geometry management. This specifies where the dimensions of the root element of the deck will come from:
        
<ul>
        
<li>auto (the default) - either &quot;children&quot; or &quot;parent&quot;, depending on the container the deck is inside; if the deck is being stretched by its ancestor then &quot;parent&quot; will be used, otherwise &quot;children&quot; will be used.</li>
        
<li>children - the deck will get its dimensions from the displayed child. This mode may degrade some animation effects.</li>
        
<li>parent - the deck will get its dimensions from the inlineStyle and if not provided from there then from its parent or if not provided from the parent then from the some default size.</li>
        </ul></td>
</tr>

<tr class="a">

<td>displayChangeListener</td>
<td>javax.el.MethodExpression</td>
<td>Only EL</td>
<td>
A method reference to a DisplayChangeListener (called in response to a DisplayChangeEvent).
         Only if a displayChangeListener is provided will the swipe gesture be enabled for the component.
         The application is expected to sync the status of external controls used for deck navigation by implementing a displayChangeListener</td>
</tr>

<tr class="b">

<td>displayedChild</td>
<td>String</td>
<td>Yes</td>
<td>

<b>Default Value:</b> <br />
<br />indicates the id of the child component that is currently displayed; if not provided or if no match is found, no child will be displayed.</td>
</tr>

<tr class="a">

<td>id</td>
<td>String</td>
<td>No</td>
<td>
<html>the identifier for the component.  Every component may be named by a component identifier that must conform to the following rules:

<ul>

<li>They must start with a letter (as defined by the Character.isLetter() method) or underscore ( _ ).</li>

<li>Subsequent characters must be letters (as defined by the Character.isLetter() method), digits as defined by the Character.isDigit() method, 
dashes ( - ), or underscores ( _ ).  To minimize the size of responses generated by JavaServer Faces, it is recommended that component identifiers 
be as short as possible. If a component has been given an identifier, it must be unique in the namespace of the closest ancestor to that component 
that is a NamingContainer (if any).</li>
</ul></html></td>
</tr>

<tr class="b">

<td>immediate</td>
<td>boolean</td>
<td>Yes</td>
<td>

<b>Default Value:</b> false<br />
<br />Whether data validation should be skipped when displayed child is being changed by this component. When immediate is false (the default), events will be delivered during the Invoke Application phase, which will trigger validation. When set to true, events will be executed during the Apply Request Values phase.</td>
</tr>

<tr class="a">

<td>inlineStyle</td>
<td>String</td>
<td>Yes</td>
<td>
the CSS styles to use for this component. This
is intended for basic style changes. The inlineStyle is a set of CSS styles
that are applied to the root DOM element of the component. Be aware that
because of browser CSS precedence rules, CSS rendered on a DOM element takes
precedence over external stylesheets like the skin file. Therefore skins
will not be able to override what you set on this attribute. If the
inlineStyle's CSS properties do not affect the DOM element you want affected,
then you will have to create a skin and use the skinning keys which are meant
to target particular DOM elements, like ::label or ::icon-style.</td>
</tr>

<tr class="b">

<td>landmark</td>
<td>String</td>
<td>Yes</td>
<td>

<b>Valid Values:</b> none, banner, complementary, contentinfo, main, navigation, search<br />

<b>Default Value:</b> none<br />
<br />specifies the WAI-ARIA landmark role for this deck.</td>
</tr>

<tr class="a">

<td>partialTriggers</td>
<td>String[]</td>
<td>Yes</td>
<td>
the IDs of the components that should trigger a partial update.
        This component will listen on the trigger components. If one of the
        trigger components receives an event that will cause it to update
        in some way, this component will request to be updated too.
        Identifiers are relative to the source component (this component), 
        and must account for NamingContainers.  If your component is already inside of a naming
        container, you can use a single colon to start the search from the root of the page,
        or multiple colons to move up through the NamingContainers - &quot;::&quot; will
        pop out of the component's naming container (or itself if the component is
        a naming container) and begin the search from there, &quot;:::&quot; will pop out of
        two naming containers (including itself if the component is a naming container)
        and begin the search from there, etc.</td>
</tr>

<tr class="b">

<td>rendered</td>
<td>boolean</td>
<td>Yes</td>
<td>

<b>Default Value:</b> true<br />
<br />whether the component is rendered. When set to false, no output will be
		delivered for this component (the component will not in any way be rendered,
		and cannot be made visible on the client). If you want to change a component's
		rendered attribute from false to true
                using PPR, set the partialTrigger attribute of its parent component so the
                parent refreshes and in turn will render this component.</td>
</tr>

<tr class="a">

<td>shortDesc</td>
<td>String</td>
<td>Yes</td>
<td>
the short description of the component. The shortDesc is also commonly used to render an
          HTML title attribute, which is used by user agents to display tooltip help text.
          The behavior for the tooltip is controlled by the user agent, e.g. Firefox 2 truncates
          long tooltips.</td>
</tr>

<tr class="b">

<td>styleClass</td>
<td>String</td>
<td>Yes</td>
<td>
a CSS style class to use for this component. The style class can
                     be defined in your jspx page or in a skinning CSS file, for example, or you
                     can use one of our public style classes, like 'AFInstructionText'.</td>
</tr>

<tr class="a">

<td>unsecure</td>
<td>java.util.Set</td>
<td>Yes</td>
<td>
A whitespace separated list of attributes whose values ordinarily can be set 
                     only on the server, but need to be settable on the client.  Currently, this 
                     is supported only for the &quot;disabled&quot; attribute. Note that when you are able to 
                     set a property on the client, you will be allowed to by using the the 
                     .setProperty('attribute', newValue) method, but not the .setXXXAttribute(newValue) 
                     method. For example, if you have unsecure=&quot;disabled&quot;, then on the client you
                     can use the method .setProperty('disabled', false), while the method
                     .setDisabled(false) will not work and will provide a javascript error that 
                     setDisabled is not a function.</td>
</tr>

<tr class="b">

<td>visible</td>
<td>boolean</td>
<td>Yes</td>
<td>

<b>Default Value:</b> true<br />
<br />the visibility of the component.  If it is &quot;false&quot;, the component will 
      be hidden on the client.  Unlike &quot;rendered&quot;, this does not affect the lifecycle on the server 
      - the component may have its bindings executed, etc. - and the visibility of the component can 
      be toggled on and off on the client, or toggled with PPR.  When &quot;rendered&quot; is false, the 
      component will not in any way be rendered, and cannot be made visible on the client. 
      In most cases, use the &quot;rendered&quot; property instead of the &quot;visible&quot; property.<br />
<b>Not supported on the following renderkits:</b> org.apache.myfaces.trinidad.core<br />
</td>
</tr>
</table>
 </div>
 

      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2019
                      Oracle Corporation.
            All Rights Reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
